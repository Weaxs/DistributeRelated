# 分布式事务

## CAP定理

CAP定理是由加州大学伯克利分校Eric Brewer教授提出来的，他指出WEB服务无法同时满足以下3个属性：

* 一致性 (Consistency)：客户端都知道一系列的操作都会同时发生(生效)
* 可用性 (Availability)：每个操作都必须以可预期的相应结束
* 分区容错性 (Partition Tolerance)：即使出现单个组件无法可用，操作依然可以完成

## BASE思想

BASE思想是对CAP的延伸，基本思想是即使无法做到强一致性，应用可以采用适合的方式达到最终一致性。同时也有一下3个属性：

* 基本可用 (Basically Availiable)：指分布式系统在出现故障的时候，可以损失部分可用性，需要保证核心可用。服务限流和降级就是其基本表现。
* 软状态 (Soft State)：指允许系统存在中间状态，而中间状态不会影响整体的可用状态。分布式存储中一般一份数据有若干个副本，允许不同节点间副本同步的延时就是软状态的体现
* 最终一致性 (Eventual Consistency)：指系统中所有的数据副本经过一定时间后，最终能够达到一致的状态。


## 事务的ACID特性
            
* 原子性(A)：在整个事务中的所有操作，要么全部完成，要么全部不做，没有中间状态
* 一致性(C)：事务的执行必须保证系统的一致性
* 隔离性(I)：事务与事务之间不会互相影响，一个事务的中间状态不会被其他事务感知
* 持久性(D)：一旦事务完成了，那么事务对数据所做的变更就完全保存在了数据库中，即使发生停电，系统宕机也是如此

## 常见的分布式事务解决方案

### 基于XA协议的两阶段提交(2PC)

XA中大致分为两部分：事务管理器和本地资源管理器。其中本地资源管理器往往由数据库实现，比如Oracle、DB2这些商业数据库都实现了XA接口，而事务管理器作为全局的调度者(一个微服务)，负责各个本地资源的提交和回滚。

* 第一阶段：

事务管理器 ———————————— 预备请求 ————————————▶ 本地资源管理器

事务管理器 ◀———————————— 就绪响应 ———————————— 本地资源管理器

* 第二阶段

事务管理器 ———————————— 提交请求 ————————————▶ 本地资源管理器

事务管理器 ◀———————————— 成功响应 ———————————— 本地资源管理器

如果其中任何一个资源管理器执行失败，则全部回滚

两阶段提交严重依赖数据库层面来搞定复杂的事务，效率低，不适合高并发的场景。

一般来说某个系统内部如果出现跨多个本地资源管理器(数据库)是不合规的。且现在的微服务，我们的规定和规范，要求每个服务只能操作自己对应的一个数据库。

故两阶段提交的应用场景较少。

### 补偿事务 (TCC)

TCC 的全称是： Try 、 Confirm 、 Cancel。TCC编程模式采用的是补偿机制，是两阶段提交的一个变种。

其核心思想是：针对每个操作，都要注册一个与其对应的确认和补偿 (撤销) 操作。业务逻辑分为三块：
* Try 阶段只要是对业务系统做检测及资源预留。
* Confirm 阶段只要是对业务系统做确认提交，即在各个服务中执行实际的操作。
* Cancel 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放。

TCC方案的事务回滚，严重依赖于自己写代码和补偿，会造成补偿代码巨大，业务代码难以维护，所以很少使用。

### Sagas 事务模型

1987年普林斯顿大学的Hector Garcia-Molina和Kenneth Salem发表了一篇Paper Sagas，讲述的是如何处理long lived transaction（长活事务）。

            Normal transactions                             Compensating transactions
            
                   T1                                                   C1
                   ↓                                                    ↑
                   T2                                                   C2
                   ↓                                                    ↑
                   T3 (fail) ————————————————————————————————→          C3
                   ...
                   Tn
Sagas 事务模型又叫做长时间运行的事务 (Long-running-transaction)

其核心思想就是拆分分布式系统中的长事务为多个短事务，或者叫多个本地事务，然后又Sagas工作流引擎负责协调，如果整个流程正常结束，那么就算是事务成功完成，如果在这过程中出现失败，那么Sagas工作流引擎就会以相反的顺序调用补偿操作，进行业务回滚。

例：此时一个长事务分为T1,T2,T3...Tn的n个短事务，在执行T3是发生了错误，则反向执行T3,T2,T1的补偿服务进行回滚。

Sagas方案更适用于业务流程长、业务流程多的情况

### 本地消息表

思路来源于eBay，其核心思想是将分布式事务拆分成本地事务进行处理。

基本思路是：

消息生产方，需要额外建一个消息表，并记录消息发送的状态。消息表和业务数据要在一个事务里提交，也就是说他们要在一个数据库里。然后消息经过MQ发送到消费方。如果消息放松失败，会进行重试发送。

消息消费方，需要处理此消息，并完成自己的业务逻辑，此时如果本地事务处理成功，表明已经处理成功了；如果处理失败，那么会重新执行；如果是业务层面的报错，可以给生产方发送一个业务补偿消息，通知生产方进行回滚补偿等操作。

生产方和消费方定时扫描本地消息表，把未处理完的消息或者失败的消息再发送一遍。

具体如下：
1. A系统在自己本地一个事务里操作的同时，插入一条数据到消息表
2. A系统将这消息发送到MQ中去
3. B系统接收到消息后，在一个事务里，往自己本地消息表里差一条数据，同时执行其他的业务操作；如果消息已经被处理，那么此时这个事务会回滚，保证不会重复处理消息
4. B系统执行成功后，就会更新自己本地消息表的状态以及A系统消息表的状态
5. 如果B系统处理失败了，那么就不会更新消息表状态，此时A系统会定时扫描自己的消息表，如果有未处理的消息，会再次发送到MQ中去，让B系统再次处理
6. 哪怕B事务失败了，但是A会不断重试发消息，直到B系统成功为止

但是这个方案**严重依赖于数据库的消息表来管理事务**，如果B失败了，需要依赖消息表来进行重试，即便是成功，也需要更新消息表的状态。

### 消息事务+最终一致性

也叫可靠消息最终一致性方案，或者MQ 事务消息

大致的意思是干脆不用本地消息表了，而是直接基于MQ来实现事务。比如阿里的 RocketMQ 就支持消息事务。

具体的步骤如下：
1. A 系统先发送一个 prepared 消息到 mq，如果这个 prepared 消息发送失败那么就直接取消操作别执行了；
2. 如果这个消息发送成功过了，那么接着执行本地事务，如果成功就告诉 mq 发送确认消息，如果失败就告诉 mq 回滚消息；
3. 如果发送了确认消息，那么此时 B 系统会接收到确认消息，然后执行本地的事务；
4. mq 会自动定时轮询所有 prepared 消息回调你的接口，问你，这个消息是不是本地事务处理失败了，所有没发送确认的消息，是继续重试还是回滚？一般来说这里你就可以查下数据库看之前本地事务是否执行，如果回滚了，那么这里也回滚吧。这个就是避免可能本地事务执行成功了，而确认消息却发送失败了。
5. 这个方案里，要是系统 B 的事务失败了咋办？重试咯，自动不断重试直到成功，如果实在是不行，要么就是针对重要的资金类业务进行回滚，比如 B 系统本地回滚后，想办法通知系统 A 也回滚；或者是发送报警由人工来手工回滚和补偿。

            A系统                     消息中间件                   B系统
               ——————发送prepared消息————→
                                     保存预备消息
               ←——————————成功返回————————
          执行本地事务
               ——————发送确认提交消息—————→
                                      保存提交消息
                                           —————————发送消息————————→
                                                                 执行本地事务
               ←————————————回调——————————
将一个分布式事务拆成一个消息事务(A的本地事务+发消息) + B系统的本地事务，其中B系统的操作有消息驱动，只要消息事务成功，那么A操作一定成功。这时候B收到消息去执行本地事务，如果操作失败，消息会重投，直到B操作成功。

同时RockerMQ会定期扫描消息集群中的事务，如果发现Prepared消息，会向消息发送者确认。

但是A和B不是严格一致的，而是最终一致的。同时，如果B的本地事务一直执行不成功，会对一致性造成破坏。
